Crear un nuevo usuario (rol) para Quarkus
üîé PASO 1: Abrir el √°rbol de objetos
Abre pgAdmin.

A la izquierda, ver√°s una barra lateral llamada "Browser" o "Navegador".

Expande este √°rbol:

pgsql
Copiar c√≥digo
Servers
‚îî‚îÄ‚îÄ PostgreSQL <tu versi√≥n>
    ‚îú‚îÄ‚îÄ Databases
    ‚îú‚îÄ‚îÄ Login/Group Roles ‚Üê ¬°Esto es lo que buscamos!
    ‚îî‚îÄ‚îÄ Tablespaces
‚ùì¬øNo ves ‚ÄúLogin/Group Roles‚Äù?
‚û°Ô∏è Haz esto:

Aseg√∫rate de que hayas iniciado sesi√≥n correctamente en tu servidor.

Si no est√° expandido, haz doble clic en PostgreSQL (donde dice tu versi√≥n, como PostgreSQL 15 o PostgreSQL 16).

Espera unos segundos, y ver√°s que aparece la carpeta Login/Group Roles.

üë§ PASO 2: Crear el nuevo usuario
Haz clic derecho sobre Login/Group Roles.

Elige: Create > Login/Group Role.

Se abre una ventana con varias pesta√±as.

‚úçÔ∏è Completa los campos as√≠:
üìÑ Pesta√±a ‚ÄúGeneral‚Äù:
Name: asistappuser

üîê Pesta√±a ‚ÄúDefinition‚Äù:
Password: 1234 (puedes cambiarla luego)

Marca ‚úÖ la opci√≥n Can login?

‚úÖ Pesta√±a ‚ÄúPrivileges‚Äù:
Marca lo siguiente:

‚úÖ Login

‚úÖ Create DB (opcional)

‚úÖ Create role (opcional)

Luego haz clic en Save.
-------------------------------------------




¬øQuieres que te ayude a revisar el contenido actual de 
Empleado.java y EmpleadoEntity.java?
Eso ayudar√° a asegurar que est√©n bien alineados con 
el mapper de EmpleadoRepositoryImpl.
------------------------------------


--
Tests paused
Press [e] to edit command line args (currently ''), [r] 
to resume testing, [o] Toggle test output, [:] for 
the terminal, [h] for more options>    

Sugerencia (para tu caso)
Como a√∫n no est√°s trabajando en pruebas autom√°ticas, 
puedes ignorar esa secci√≥n de momento.
Cuando aprendas testing, este modo ser√° muy √∫til, 
pero por ahora no necesitas preocuparte por los mensajes de 
Tests paused.
---------------------------------------


Si solo quieres usar tu aplicaci√≥n:
Abre tu navegador y ve a: üëâ http://localhost:8080

O accede a GraphQL UI: üëâ http://localhost:8080/q/graphql-ui
-----------------------------------

GraphQL Resolver
‚îî‚îÄ‚îÄ llama a RegisterAttendanceUseCase.registrar()
     ‚îî‚îÄ‚îÄ implementado por RegisterAttendanceService
         ‚îî‚îÄ‚îÄ llama a AttendanceRepository.save()
             ‚îî‚îÄ‚îÄ implementado por AttendanceRepositoryImpl
                 ‚îî‚îÄ‚îÄ usa EntityManager para guardar en la base de datos (AttendanceEntity)
------------------------------------------

Para estudiar este flujo, estos son los archivos clave que ya tienes:
| Tipo              | Archivo                          | Ubicaci√≥n                               | Funci√≥n                                   |
| ----------------- | -------------------------------- | --------------------------------------- | ----------------------------------------- |
| üß† Modelo         | `Attendance.java`                | `domain/model`                          | Representa una asistencia                 |
| üß© Interfaz       | `RegisterAttendanceUseCase.java` | `domain/ports/in`                       | Define qu√© se puede hacer con asistencias |
| üîß Servicio       | `RegisterAttendanceService.java` | `application/usecases`                  | Implementa el registro de asistencia      |
| üõ† Repositorio    | `AttendanceRepository.java`      | `domain/ports/out`                      | Firma para acceder a la base de datos     |
| üíæ Implementaci√≥n | `AttendanceRepositoryImpl.java`  | `infrastructure/persistence/repository` | Guarda en la base de datos                |
| üóÉÔ∏è Entidad       | `AttendanceEntity.java`          | `infrastructure/persistence/entity`     | Mapeo a tabla `attendance`                |
----------------------------------------


üß† Si quieres estudiar paso a paso (recomendado):
Empieza por el modelo Attendance.

Luego pasa a RegisterAttendanceUseCase 
para ver qu√© se espera hacer.

Estudia c√≥mo RegisterAttendanceService implementa eso.

Y c√≥mo se guarda usando AttendanceRepositoryImpl y 
AttendanceEntity.
------------------------------------

Attendance.java (modelo)

AttendanceRepository.java (puerto de salida)

AttendanceRepositoryImpl.java (implementaci√≥n)

GetAttendanceByEmployeeUseCase.java (puerto de entrada)

GetAttendanceByEmployeeService.java (servicio)

RegisterAttendanceUseCase.java (puerto de entrada)

RegisterAttendanceService.java (servicio)

AttendanceResolver.java (resolvers GraphQL)

schema.graphql (definici√≥n de tipos y operaciones)
----------------------------------------------------


Ports and Adapters
domain (modelo puro y puertos)
application (casos de uso)
infrastructure (resolvers, persistencia)
---------------------------------------------


Ciclo de vida completo de esta query

query {
  listarAsistencias(empleadoId: 1) {
    id
    tipo
    fecha
    empleadoId
  }
}


schema.graphql

type Query {
  listarAsistencias(empleadoId: Int!): [Attendance]
}
; la query (listarAsistencias), qu√© par√°metros recibe, 
; y qu√© tipo devuelve.


AttendanceResolver.java

@GraphQLApi
@ApplicationScoped
public class AttendanceResolver {
    @Inject
    GetAttendanceByEmployeeUseCase useCase;

    public List<Attendance> consultarAsistencias(Long empleadoId) {
        return useCase.obtenerPorEmpleado(empleadoId);
    }
}
; Quarkus ve el nombre del m√©todo consultarAsistencias, 
; y lo expone como listarAsistencias por convenci√≥n 
; (esto puedes ajustarlo si usas @Query("listarAsistencias")).
; Aqu√≠ se llama al puerto de entrada del dominio.


GetAttendanceByEmployeeUseCase.java

public interface GetAttendanceByEmployeeUseCase {
    List<Attendance> obtenerPorEmpleado(Long empleadoId);
}
;Define qu√© debe poder hacer el dominio (pero no c√≥mo).


GetAttendanceByEmployeeService.java

@ApplicationScoped
public class GetAttendanceByEmployeeService implements GetAttendanceByEmployeeUseCase {
    @Inject
    AttendanceRepository repository;

    public List<Attendance> obtenerPorEmpleado(Long empleadoId) {
        return repository.findByEmployeeId(empleadoId);
    }
}
; Implementa el caso de uso.
; Llama a un puerto de salida (AttendanceRepository).


AttendanceRepository.java

public interface AttendanceRepository {
    List<Attendance> findByEmployeeId(Long employeeId);
}
;El dominio espera que alguien implemente esta interfaz.


AttendanceRepositoryImpl.java

public class AttendanceRepositoryImpl implements AttendanceRepository {
    @PersistenceContext
    EntityManager em;

    public List<Attendance> findByEmployeeId(Long id) {
        // consulta a la base de datos y devuelve lista
    }
}
; Consulta la base de datos (PostgreSQL).
; Convierte AttendanceEntity en Attendance y los devuelve.
; Finalmente, la lista de Attendance viaja de vuelta hasta AttendanceResolver, 
; y es serializada en GraphQL como JSON para ti.


GraphQL UI (consulta)
    ‚Üì
schema.graphql (verifica) define todas consultas y argumentos
    ‚Üì
Resolver (implementa) conecta schema con dominio (c√≥mo es necesario esta parte?)
    ‚Üì
Use Case Interface (intruye) c√≥mo se debe implementar
    ‚Üì
Use Case Service (implementa) actua sobre repositorio
    ‚Üì
Repository Interface (verifica lo necesitado) 
    ‚Üì
Repository Impl (accede) JPA para guardar en DB
    ‚Üì
Base de Datos (guarda o devuelve)
--------------------------------------------------------------

Ciclo de vida de solicitudes

GraphQL Client (solicita)
    ‚Üì
GraphQL Schema (define contrato API: tipos, queries y mutaciones)
    ‚Üì
Resolver Adapter (Adaptador Primario: traduce solicitud a comando de aplicaci√≥n)
    ‚Üì
Use Case Port (interfaz que declara l√≥gica de negocio)
    ‚Üì
Use Case Service (implementa reglas de negocio y coordina flujos)
    ‚Üì
Repository Port (interfaz que abstrae acceso a datos)
    ‚Üì
Repository Adapter (Adaptador Secundario: implementa persistencia concreta)
    ‚Üì
Base de Datos (almacenamiento persistente)
-------------------------------------------------------------

Responsabilidades

¬øpor qu√© es necesario?
----------------------------------------


Cliente->>Schema: { user(id: "123") { name email } }
    Schema-->>Resolver: Valida y enruta query
    Resolver->>UseCasePort: getUserById("123")
    UseCasePort->>UseCaseImpl: Ejecuta implementaci√≥n
    UseCaseImpl->>RepoPort: findById(123)
    RepoPort->>RepoImpl: Llama implementaci√≥n JPA
    RepoImpl->>DB: SELECT * FROM users...
    DB-->>RepoImpl: Datos brutos
    RepoImpl-->>RepoPort: User entity
    RepoPort-->>UseCaseImpl: Objeto dominio
    UseCaseImpl-->>UseCasePort: User validado
    UseCasePort-->>Resolver: DTO de dominio
    Resolver-->>Schema: Convierte a GraphQL User
    Schema-->>Cliente: { "user": { "name": "Ana", ... } }
----------------------------------------------------------
peticion
Cliente->>Schema: { user(id: "123") { name email } }
----------------------------------------------------------------------------
Schema-->>Resolver: Valida y enruta query
schema.graphql
contrato 
.;Define el contrato p√∫blico (tipos, queries, mutaciones)
; ; ; type Query {
; ; ;   user(id: ID!): User
; ; ; }
; ; ; type User {
; ; ;   id: ID!
; ; ;   name: String!
; ; ;   email: String!
; ; ; }
- actions  ;GraphQL requiere un esquema fuertemente tipado para validar peticiones
;valida peticion
-> flujo ;Valida y enruta query
---------------------------------------------------------------
Resolver->>UseCasePort: getUserById("123");Recibe argumentos crudos
Resolver
Adaptador primario
; ; ; @RequiredArgsConstructor
; ; ; public class UserResolver implements GraphQLQueryResolver {
    
; ; ;     private final UserService userService; // Puerto
    
; ; ;     public UserResponse user(String id) {
; ; ;         try {
; ; ;             return userService.getUserById(new UserId(id));
; ; ;         } catch (UserNotFoundException e) {
; ; ;             throw new GraphQLException("Usuario no encontrado");
; ; ;         }
; ; ;     }
; ; ; }
actions ;recibe argumentos crudos ;convierte inputs a objetos de dominio ;invoca al caso de uso ;maneja errores ;convierte respuestas
; "Adapto: GraphQL ‚Üí Dominio"
; "Invoco: Caso de Uso"
; Convierto: Dominio ‚Üí GraphQL"
flujo ->;Act√∫a como traductor entre el protocolo GraphQL y tu dominio
--------------------------------------------------------------------
UseCasePort->>UseCaseImpl: Ejecuta implementaci√≥n
UseCase Port
contrato de negocio
.;Define la interfaz abstracta de operaciones de negocio
; ; ; public interface UserService {
; ; ;     UserResponse getUserById(UserId id) throws UserNotFoundException;
; ; ; }
actions ;Permite invertir dependencias. ;El dominio define qu√© necesita, no c√≥mo se implementa. 
;Crucial para testeo y cambiar implementaciones.
-> flujo (que lo hace enviar a otro archivo) ;
----------------------------------------------------------------------------------------------
UseCaseImpl->>RepoPort: findById(123)
UseCaseImpl
;Contiene la logica de negocio central ;ejecuta reglas de negocio
; ; ; @Service
; ; ; @RequiredArgsConstructor
; ; ; public class UserServiceImpl implements UserService {
    
; ; ;     private final UserRepository repository;
    
; ; ;     public UserResponse getUserById(UserId id) {
; ; ;         User user = repository.findById(id)
; ; ;             .orElseThrow(() -> new UserNotFoundException(id));
        
; ; ;         if (user.isDeactivated()) {
; ; ;             throw new IllegalStateException("Usuario desactivado");
; ; ;         }
        
; ; ;         return UserResponse.fromDomain(user);
; ; ;     }
; ; ; }
actions ;orquesta flujos entre repositorios ;aplica reglas de negocio
; "Orquesto flujos"
; "Aplico reglas"
; "Decido: mutation o query?"
-> flujo ;
- porque ;esta separado del resolver, l√≥gica HTTP y reglas de negocio deben estarlo, 
;permite reutilizar la LOGICA en diferentes CONTEXTOS (cli, rest, etc)
----------------------------------------------------------------------------------------------
RepoPort->>RepoImpl: Llama implementaci√≥n JPA
RepoPort
Define Repositorio
;define operaciones de persistencia abstracta ;declara como se acceden a la DB
; ; ; public interface UserRepository {
; ; ;     Optional<User> findById(UserId id);
; ; ;     User save(User user);
; ; ; }
actions ;
-> flujo ;
porque ;desacopla el dominio de la infraestructura. 
;da la posibilidad de cambiar de mysql a mongoDB sin tocar dominio
-------------------------------------------------------------------------------------------
RepoImpl->>DB: SELECT * FROM users...
RepoImpl
Adaptador de repositorio
;implementar persistencia concreta usando JPA en la DB
; ; ; @Repository
; ; ; public class JpaUserRepository implements UserRepository {
    
; ; ;     private final UserJpaRepository jpaRepo;
    
; ; ;     public Optional<User> findById(UserId id) {
; ; ;         return jpaRepo.findById(id.value())
; ; ;             .map(this::toDomain);
; ; ;     }
    
; ; ;     private User toDomain(UserEntity entity) {
; ; ;         return new User(
; ; ;             new UserId(entity.getId()),
; ; ;             entity.getName(),
; ; ;             entity.getEmail()
; ; ;         );
; ; ;     }
; ; ; }
actions ;
-> flujo ;
porque ;Si implement√°ramos JPA directamente en el servicio, estar√≠as acoplado a Hibernate. 
;Esto permite cambiar tecnolog√≠as f√°cilmente.
--------------------------------------------------------------------------------------------
DB-->>RepoImpl: Datos brutos
DB

-------------------------------------------------------------------------------------------
RepoImpl-->>RepoPort: User entity
-------------------------------------------------------------------------------------------
RepoPort-->>UseCaseImpl: Objeto dominio
-------------------------------------------------------------------------------------------
UseCaseImpl-->>UseCasePort: User validado
-------------------------------------------------------------------------------------------
UseCasePort-->>Resolver: DTO de dominio
-------------------------------------------------------------------------------------------
Resolver-->>Schema: Convierte a GraphQL User
----------------------------------------------------------------------------------
Schema-->>Cliente: { "user": { "name": "Ana", ... } }
---------------------------------------------------------------------

Sin repositorio: La l√≥gica de negocio se mezcla con SQL/JPQL
Sin servicio: El resolver contendr√≠a reglas de negocio (imposible reusar)
Sin puertos: Dependencias directas imposibilitan mocks para tests
============================================================================

Beneficios Clave de Esta Estructura
Testabilidad unitaria:
Puedes testear el servicio con un mock del repositorio
Puedes testear el resolver con un mock del servicio

Cambios seguros:
Modificar GraphQL no afecta negocio
Cambiar base de datos no rompe reglas de negocio

Escalabilidad:
Nuevos adaptadores (Ej: a√±adir API REST) sin modificar n√∫cleo
F√°cil a√±adir cach√© (implementando un decorador del repositorio)
===============================================================================

¬øCu√°ndo es overkill?
Para proyectos:
Muy peque√±os (prototipos, MVPs)
De solo CRUD sin l√≥gica de negocio compleja
Con requisitos de persistencia fijos y √∫nicos

En estos casos, podr√≠as:
Combinar servicio y repositorio
Usar Active Record en lugar de Repository
Eliminar interfaces si solo hay una implementaci√≥n

La arquitectura hexagonal brilla cuando tienes:
Reglas de negocio complejas
M√∫ltiples formas de interacci√≥n (API, CLI, etc.)
Necesidad de cambiar infraestructura frecuentemente
Sistema de larga vida con evoluci√≥n constante
======================================================================================

=================================================================================

Flujo de una Query o Mutation GraphQL en Arquitectura de puertos y adaptadores
peticion 
contrato (schema graphql)
conecta (resolvers)
declara (use case)
orquesta (use case service)
abstrae (repository interface)
persiste (repository impl)
act√∫a (DB)


---------------------
recibe 
funcion (valida, transforma, decide)
invoca (env√≠a)

---------------------------------------------
Principio de Responsabilidad √önica y 
la Regla de Dependencia Inversa (depender de abstracciones, no implementaciones).

Camino de vuelta:
   - Adaptador: Convierte registro ‚Üí Entidad
   - Servicio: Convierte Entidad ‚Üí DTO {id, nombre}
   - Resolver: Convierte DTO ‚Üí {usuario: {id: "X", nombre: "Ana"}}
----------------------------------------------------


graphql 
-input: peticion
process: 
contruye operacion graphql
-output: solicitud 

schema graphql
-imput: solicitud
process: 
valida
-output: argumento graphql

resolver
-input: argumento graphql
process: 
convierte datos a objetos de dominio
maneja errores basicos
-output: consulta de dominio

PORT use case port
-input: consulta de dominio
process:
define contrato abstracto
-output: objeto de dominio validado

ADAPTER "use case service - domain service - use case impl - use case adapter"
-input: objeto de dominio validado
process:
aplica reglas de negocio
toma decisiones
orquesta flujos
-output: instruccion de persistencia

PORT repository port
-input: instruccion de persistencia
process:
define contrato abstracto
-output: entidad de dominio

ADAPTER "repository impl - repository adapter"
-input: entidad de dominio
process:
mapea objetos
convierte a modelo de persitencia
-output: instruccion

DB
-input: instruction
process:
ejecuta instruccion
-output: 
---------------------------------------------------------------------------------------------------
flujo l√≥gico y arquitect√≥nico de una operaci√≥n GraphQL con arquitectura hexagonal


1. GraphQL UI (frontend / comensal)

Input: Petici√≥n desde el navegador o frontend

Proceso: Construye y env√≠a una operaci√≥n GraphQL (query o mutation)

Output: Solicitud GraphQL enviada al backend

2. schema.graphql (men√∫)

Input: Solicitud GraphQL

Proceso:

Valida el nombre de la operaci√≥n

Valida los tipos y argumentos

Output: Argumentos correctos para el resolver

3. Resolver (mesero)

Input: Argumentos GraphQL validados

Proceso:

Convierte datos en objetos del dominio

Maneja errores b√°sicos

Llama al caso de uso correspondiente

Output: Consulta o comando del dominio

4. Use Case Port (pedido escrito / contrato del chef)

Input: Consulta o comando del dominio

Proceso:

Define la interfaz (contrato)

Declara qu√© se necesita del dominio, sin implementar

Output: Objeto del dominio validado

5. Use Case Service (chef)

Input: Objeto del dominio validado

Proceso:

Aplica l√≥gica de negocio (reglas)

Orquesta llamadas a los repositorios

Output: Instrucci√≥n de persistencia o resultado

6. Repository Port (pedido a cocina)

Input: Instrucci√≥n de persistencia

Proceso:

Define el contrato para acceder a los datos

Output: Objeto del dominio listo para persistir

7. Repository Implementation (cocina)

Input: Objeto de dominio

Proceso:

Mapea objeto de dominio a entidad JPA

Usa JPA para acceder a la base de datos

Output: Instrucci√≥n SQL / resultado persistido

8. Base de Datos (despensa)

Input: Instrucci√≥n SQL

Proceso:

Ejecuta consulta, inserci√≥n o actualizaci√≥n

Output: Datos le√≠dos o confirmaci√≥n de guardado

Analog√≠a completa con el restaurante (8 elementos)

Comensal (GraphQL UI)

Hace la petici√≥n de un plato

Men√∫ (schema.graphql)

Muestra qu√© platos existen y c√≥mo pedirlos

Mesero (Resolver)

Toma la orden, la valida y la lleva a la cocina

Pedido escrito (Use Case Port)

Especificaci√≥n formal de qu√© se pidi√≥ y c√≥mo debe prepararse

Chef (Use Case Service)

Decide c√≥mo preparar el plato seg√∫n reglas del restaurante

Pedido a cocina (Repository Port)

Solicita ingredientes o preparaci√≥n espec√≠fica a la cocina

Cocina (Repository Impl)

Prepara el plato real con acceso a ingredientes

Despensa (Base de Datos)

Guarda y suministra los ingredientes (datos)



===========================================================================================
GraphQL Input ‚Üí Comando Dominio ‚Üí Entidad ‚Üí Modelo Persistencia ‚Üí Almacenamiento
=============================================================================================

Validaciones

Logging

Cach√©

Transformaciones


---------------------------------------------------------

üß† Resumen del Proyecto: AsistApp
üéØ Objetivo
Desarrollar una aplicaci√≥n de gesti√≥n de asistencias para empleados, usando Quarkus, GraphQL, y arquitectura hexagonal (clean architecture).

üèõÔ∏è Arquitectura Hexagonal Aplicada
La app sigue una estructura por capas, separando responsabilidades de forma clara:

java
Copiar c√≥digo
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ GraphQL UI ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ         (Frontend - navegador)     ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚ñº
                 schema.graphql (men√∫)
                        ‚ñº
                 Resolver (mesero)
                        ‚ñº
            Use Case Port (contrato del chef)
                        ‚ñº
          Use Case Impl/Service (chef principal)
                        ‚ñº
           Repository Port (pedido a cocina)
                        ‚ñº
         Repository Impl (cocina con JPA/SQL)
                        ‚ñº
             Base de datos PostgreSQL (despensa)
üìÅ Estructura de carpetas
plaintext
Copiar c√≥digo
src/
‚îî‚îÄ main/
   ‚îú‚îÄ java/com/joyit/
   ‚îÇ  ‚îú‚îÄ application/usecases/   ‚Üê l√≥gica del negocio
   ‚îÇ  ‚îú‚îÄ domain/model/           ‚Üê entidades del dominio
   ‚îÇ  ‚îú‚îÄ domain/ports/in/        ‚Üê interfaces de casos de uso
   ‚îÇ  ‚îú‚îÄ domain/ports/out/       ‚Üê interfaces de repositorio
   ‚îÇ  ‚îú‚îÄ infrastructure/
   ‚îÇ  ‚îÇ  ‚îú‚îÄ graphql/resolvers/   ‚Üê resolvers GraphQL
   ‚îÇ  ‚îÇ  ‚îú‚îÄ persistence/entity/  ‚Üê entidades JPA
   ‚îÇ  ‚îÇ  ‚îú‚îÄ persistence/repository/ ‚Üê repositorios JPA
   ‚îÇ  ‚îî‚îÄ AsistApp.java           ‚Üê punto de entrada
   ‚îú‚îÄ resources/
   ‚îÇ  ‚îú‚îÄ META-INF/resources/graphql/schema.graphql ‚Üê esquema GraphQL
   ‚îÇ  ‚îî‚îÄ application.properties  ‚Üê configuraci√≥n Quarkus
üì¶ Dependencias clave (en pom.xml)
quarkus-smallrye-graphql ‚Üí Para usar GraphQL

quarkus-hibernate-orm-panache ‚Üí ORM con JPA

quarkus-jdbc-postgresql ‚Üí Driver PostgreSQL

quarkus-arc ‚Üí Inyecci√≥n de dependencias

quarkus-rest-jackson, quarkus-rest ‚Üí (opcional) para REST

quarkus-smallrye-jwt ‚Üí Seguridad con JWT (si decides usarla)

üß© Entidades importantes
Attendance.java (Dominio)
id: Int

tipo: String

fecha: String

empleadoId: Int

AttendanceEntity.java (JPA)
Equivalente al modelo Attendance, mapeado con @Entity.

üîß Funcionalidad implementada (GraphQL)
‚úÖ Query
graphql
Copiar c√≥digo
query {
  listarAsistencias(empleadoId: 1) {
    id
    tipo
    fecha
    empleadoId
  }
}
‚úÖ Mutation
graphql
Copiar c√≥digo
mutation {
  registrarAsistencia(
    id: 1,
    tipo: "entrada",
    fecha: "2025-07-29",
    empleadoId: 1
  ) {
    id
    tipo
    fecha
    empleadoId
  }
}
Resolver asociado: AttendanceResolver.java
Llama a los casos de uso

Conecta con GetAttendanceByEmployeeUseCase y RegisterAttendanceUseCase

‚úÖ Estado actual
üü¢ El servidor levanta correctamente en http://localhost:8080/q/graphql-ui

üü¢ Se pueden hacer consultas y mutaciones exitosas

üü¢ No hay errores en la consola ni conflictos de dependencias

üü¢ Diagramas .puml organizados por tipo en uml-diagrams/

üß™ Se elimin√≥ el test de ejemplo fallido (GreetingResourceTest)

üìå Se entiende el ciclo de vida completo de una operaci√≥n GraphQL

---------------------------------------------------------------

üß† C√≥mo fluye una petici√≥n GraphQL
Frontend (GraphQL Playground o cliente) hace una petici√≥n.

schema.graphql valida la estructura de la operaci√≥n.

Resolver recibe argumentos y llama al caso de uso (interface).

La implementaci√≥n del caso de uso orquesta la l√≥gica.

Llama al puerto de repositorio.

La implementaci√≥n del repositorio convierte a entidad y usa JPA.

La base de datos guarda o devuelve datos.

Todo el camino de vuelta sube hasta el cliente.

--------------------------------------------------------

 Recomendaciones para seguir
‚úÖ Seguir creando queries y mutations para Employee, UserAccount, etc.

üéØ Aprender testing con QuarkusTest (cuando est√©s listo).

üìö Estudiar validaciones con Bean Validation (@NotNull, etc.).

üß© A√±adir seguridad (JWT) si se requiere login real.

üóÉÔ∏è Usar m√°s funcionalidades de Panache o repositorios custom.
------------------------------------------------------

Si el backend s√≠ est√° corriendo pero el error persiste, necesito los siguientes archivos:
‚ö†Ô∏è Puedes envi√°rmelos uno por uno si lo prefieres, o copiar su contenido aqu√≠.

AttendanceResolver.java
(est√° en infrastructure/graphql/resolvers/)

schema.graphql
(en resources/META-INF/resources/graphql/)

application.properties
(en resources/)

AttendanceEntity.java
(por si hay conflicto con JPA)

GetAttendanceByEmployeeUseCase.java

GetAttendanceByEmployeeService.java

AttendanceRepository.java

AttendanceRepositoryImpl.java


