Crear un nuevo usuario (rol) para Quarkus
ğŸ” PASO 1: Abrir el Ã¡rbol de objetos
Abre pgAdmin.

A la izquierda, verÃ¡s una barra lateral llamada "Browser" o "Navegador".

Expande este Ã¡rbol:

pgsql
Copiar cÃ³digo
Servers
â””â”€â”€ PostgreSQL <tu versiÃ³n>
    â”œâ”€â”€ Databases
    â”œâ”€â”€ Login/Group Roles â† Â¡Esto es lo que buscamos!
    â””â”€â”€ Tablespaces
â“Â¿No ves â€œLogin/Group Rolesâ€?
â¡ï¸ Haz esto:

AsegÃºrate de que hayas iniciado sesiÃ³n correctamente en tu servidor.

Si no estÃ¡ expandido, haz doble clic en PostgreSQL (donde dice tu versiÃ³n, como PostgreSQL 15 o PostgreSQL 16).

Espera unos segundos, y verÃ¡s que aparece la carpeta Login/Group Roles.

ğŸ‘¤ PASO 2: Crear el nuevo usuario
Haz clic derecho sobre Login/Group Roles.

Elige: Create > Login/Group Role.

Se abre una ventana con varias pestaÃ±as.

âœï¸ Completa los campos asÃ­:
ğŸ“„ PestaÃ±a â€œGeneralâ€:
Name: asistappuser

ğŸ” PestaÃ±a â€œDefinitionâ€:
Password: 1234 (puedes cambiarla luego)

Marca âœ… la opciÃ³n Can login?

âœ… PestaÃ±a â€œPrivilegesâ€:
Marca lo siguiente:

âœ… Login

âœ… Create DB (opcional)

âœ… Create role (opcional)

Luego haz clic en Save.
-------------------------------------------




Â¿Quieres que te ayude a revisar el contenido actual de 
Empleado.java y EmpleadoEntity.java?
Eso ayudarÃ¡ a asegurar que estÃ©n bien alineados con 
el mapper de EmpleadoRepositoryImpl.
------------------------------------


--
Tests paused
Press [e] to edit command line args (currently ''), [r] 
to resume testing, [o] Toggle test output, [:] for 
the terminal, [h] for more options>    

Sugerencia (para tu caso)
Como aÃºn no estÃ¡s trabajando en pruebas automÃ¡ticas, 
puedes ignorar esa secciÃ³n de momento.
Cuando aprendas testing, este modo serÃ¡ muy Ãºtil, 
pero por ahora no necesitas preocuparte por los mensajes de 
Tests paused.
---------------------------------------


Si solo quieres usar tu aplicaciÃ³n:
Abre tu navegador y ve a: ğŸ‘‰ http://localhost:8080

O accede a GraphQL UI: ğŸ‘‰ http://localhost:8080/q/graphql-ui
-----------------------------------

GraphQL Resolver
â””â”€â”€ llama a RegisterAttendanceUseCase.registrar()
     â””â”€â”€ implementado por RegisterAttendanceService
         â””â”€â”€ llama a AttendanceRepository.save()
             â””â”€â”€ implementado por AttendanceRepositoryImpl
                 â””â”€â”€ usa EntityManager para guardar en la base de datos (AttendanceEntity)
------------------------------------------

Para estudiar este flujo, estos son los archivos clave que ya tienes:
| Tipo              | Archivo                          | UbicaciÃ³n                               | FunciÃ³n                                   |
| ----------------- | -------------------------------- | --------------------------------------- | ----------------------------------------- |
| ğŸ§  Modelo         | `Attendance.java`                | `domain/model`                          | Representa una asistencia                 |
| ğŸ§© Interfaz       | `RegisterAttendanceUseCase.java` | `domain/ports/in`                       | Define quÃ© se puede hacer con asistencias |
| ğŸ”§ Servicio       | `RegisterAttendanceService.java` | `application/usecases`                  | Implementa el registro de asistencia      |
| ğŸ›  Repositorio    | `AttendanceRepository.java`      | `domain/ports/out`                      | Firma para acceder a la base de datos     |
| ğŸ’¾ ImplementaciÃ³n | `AttendanceRepositoryImpl.java`  | `infrastructure/persistence/repository` | Guarda en la base de datos                |
| ğŸ—ƒï¸ Entidad       | `AttendanceEntity.java`          | `infrastructure/persistence/entity`     | Mapeo a tabla `attendance`                |
----------------------------------------


ğŸ§  Si quieres estudiar paso a paso (recomendado):
Empieza por el modelo Attendance.

Luego pasa a RegisterAttendanceUseCase 
para ver quÃ© se espera hacer.

Estudia cÃ³mo RegisterAttendanceService implementa eso.

Y cÃ³mo se guarda usando AttendanceRepositoryImpl y 
AttendanceEntity.
------------------------------------

Attendance.java (modelo)

AttendanceRepository.java (puerto de salida)

AttendanceRepositoryImpl.java (implementaciÃ³n)

GetAttendanceByEmployeeUseCase.java (puerto de entrada)

GetAttendanceByEmployeeService.java (servicio)

RegisterAttendanceUseCase.java (puerto de entrada)

RegisterAttendanceService.java (servicio)

AttendanceResolver.java (resolvers GraphQL)

schema.graphql (definiciÃ³n de tipos y operaciones)
----------------------------------------------------


Ports and Adapters
domain (modelo puro y puertos)
application (casos de uso)
infrastructure (resolvers, persistencia)
---------------------------------------------


Ciclo de vida completo de esta query

query {
  listarAsistencias(empleadoId: 1) {
    id
    tipo
    fecha
    empleadoId
  }
}


schema.graphql

type Query {
  listarAsistencias(empleadoId: Int!): [Attendance]
}
; la query (listarAsistencias), quÃ© parÃ¡metros recibe, 
; y quÃ© tipo devuelve.


AttendanceResolver.java

@GraphQLApi
@ApplicationScoped
public class AttendanceResolver {
    @Inject
    GetAttendanceByEmployeeUseCase useCase;

    public List<Attendance> consultarAsistencias(Long empleadoId) {
        return useCase.obtenerPorEmpleado(empleadoId);
    }
}
; Quarkus ve el nombre del mÃ©todo consultarAsistencias, 
; y lo expone como listarAsistencias por convenciÃ³n 
; (esto puedes ajustarlo si usas @Query("listarAsistencias")).
; AquÃ­ se llama al puerto de entrada del dominio.


GetAttendanceByEmployeeUseCase.java

public interface GetAttendanceByEmployeeUseCase {
    List<Attendance> obtenerPorEmpleado(Long empleadoId);
}
;Define quÃ© debe poder hacer el dominio (pero no cÃ³mo).


GetAttendanceByEmployeeService.java

@ApplicationScoped
public class GetAttendanceByEmployeeService implements GetAttendanceByEmployeeUseCase {
    @Inject
    AttendanceRepository repository;

    public List<Attendance> obtenerPorEmpleado(Long empleadoId) {
        return repository.findByEmployeeId(empleadoId);
    }
}
; Implementa el caso de uso.
; Llama a un puerto de salida (AttendanceRepository).


AttendanceRepository.java

public interface AttendanceRepository {
    List<Attendance> findByEmployeeId(Long employeeId);
}
;El dominio espera que alguien implemente esta interfaz.


AttendanceRepositoryImpl.java

public class AttendanceRepositoryImpl implements AttendanceRepository {
    @PersistenceContext
    EntityManager em;

    public List<Attendance> findByEmployeeId(Long id) {
        // consulta a la base de datos y devuelve lista
    }
}
; Consulta la base de datos (PostgreSQL).
; Convierte AttendanceEntity en Attendance y los devuelve.
; Finalmente, la lista de Attendance viaja de vuelta hasta AttendanceResolver, 
; y es serializada en GraphQL como JSON para ti.


GraphQL UI (consulta)
    â†“
schema.graphql (verifica) define todas consultas y argumentos
    â†“
Resolver (implementa) conecta schema con dominio (cÃ³mo es necesario esta parte?)
    â†“
Use Case Interface (intruye) cÃ³mo se debe implementar
    â†“
Use Case Service (implementa) actua sobre repositorio
    â†“
Repository Interface (verifica lo necesitado) 
    â†“
Repository Impl (accede) JPA para guardar en DB
    â†“
Base de Datos (guarda o devuelve)
--------------------------------------------------------------

Ciclo de vida de solicitudes

GraphQL Client (solicita)
    â†“
GraphQL Schema (define contrato API: tipos, queries y mutaciones)
    â†“
Resolver Adapter (Adaptador Primario: traduce solicitud a comando de aplicaciÃ³n)
    â†“
Use Case Port (interfaz que declara lÃ³gica de negocio)
    â†“
Use Case Service (implementa reglas de negocio y coordina flujos)
    â†“
Repository Port (interfaz que abstrae acceso a datos)
    â†“
Repository Adapter (Adaptador Secundario: implementa persistencia concreta)
    â†“
Base de Datos (almacenamiento persistente)
-------------------------------------------------------------

Responsabilidades

Â¿por quÃ© es necesario?
----------------------------------------


Cliente->>Schema: { user(id: "123") { name email } }
    Schema-->>Resolver: Valida y enruta query
    Resolver->>UseCasePort: getUserById("123")
    UseCasePort->>UseCaseImpl: Ejecuta implementaciÃ³n
    UseCaseImpl->>RepoPort: findById(123)
    RepoPort->>RepoImpl: Llama implementaciÃ³n JPA
    RepoImpl->>DB: SELECT * FROM users...
    DB-->>RepoImpl: Datos brutos
    RepoImpl-->>RepoPort: User entity
    RepoPort-->>UseCaseImpl: Objeto dominio
    UseCaseImpl-->>UseCasePort: User validado
    UseCasePort-->>Resolver: DTO de dominio
    Resolver-->>Schema: Convierte a GraphQL User
    Schema-->>Cliente: { "user": { "name": "Ana", ... } }
----------------------------------------------------------
peticion
Cliente->>Schema: { user(id: "123") { name email } }
----------------------------------------------------------------------------
Schema-->>Resolver: Valida y enruta query
schema.graphql
contrato 
.;Define el contrato pÃºblico (tipos, queries, mutaciones)
; ; ; type Query {
; ; ;   user(id: ID!): User
; ; ; }
; ; ; type User {
; ; ;   id: ID!
; ; ;   name: String!
; ; ;   email: String!
; ; ; }
- actions  ;GraphQL requiere un esquema fuertemente tipado para validar peticiones
;valida peticion
-> flujo ;Valida y enruta query
---------------------------------------------------------------
Resolver->>UseCasePort: getUserById("123");Recibe argumentos crudos
Resolver
Adaptador primario
; ; ; @RequiredArgsConstructor
; ; ; public class UserResolver implements GraphQLQueryResolver {
    
; ; ;     private final UserService userService; // Puerto
    
; ; ;     public UserResponse user(String id) {
; ; ;         try {
; ; ;             return userService.getUserById(new UserId(id));
; ; ;         } catch (UserNotFoundException e) {
; ; ;             throw new GraphQLException("Usuario no encontrado");
; ; ;         }
; ; ;     }
; ; ; }
actions ;recibe argumentos crudos ;convierte inputs a objetos de dominio ;invoca al caso de uso ;maneja errores ;convierte respuestas
; "Adapto: GraphQL â†’ Dominio"
; "Invoco: Caso de Uso"
; Convierto: Dominio â†’ GraphQL"
flujo ->;ActÃºa como traductor entre el protocolo GraphQL y tu dominio
--------------------------------------------------------------------
UseCasePort->>UseCaseImpl: Ejecuta implementaciÃ³n
UseCase Port
contrato de negocio
.;Define la interfaz abstracta de operaciones de negocio
; ; ; public interface UserService {
; ; ;     UserResponse getUserById(UserId id) throws UserNotFoundException;
; ; ; }
actions ;Permite invertir dependencias. ;El dominio define quÃ© necesita, no cÃ³mo se implementa. 
;Crucial para testeo y cambiar implementaciones.
-> flujo (que lo hace enviar a otro archivo) ;
----------------------------------------------------------------------------------------------
UseCaseImpl->>RepoPort: findById(123)
UseCaseImpl
;Contiene la logica de negocio central ;ejecuta reglas de negocio
; ; ; @Service
; ; ; @RequiredArgsConstructor
; ; ; public class UserServiceImpl implements UserService {
    
; ; ;     private final UserRepository repository;
    
; ; ;     public UserResponse getUserById(UserId id) {
; ; ;         User user = repository.findById(id)
; ; ;             .orElseThrow(() -> new UserNotFoundException(id));
        
; ; ;         if (user.isDeactivated()) {
; ; ;             throw new IllegalStateException("Usuario desactivado");
; ; ;         }
        
; ; ;         return UserResponse.fromDomain(user);
; ; ;     }
; ; ; }
actions ;orquesta flujos entre repositorios ;aplica reglas de negocio
; "Orquesto flujos"
; "Aplico reglas"
; "Decido: mutation o query?"
-> flujo ;
- porque ;esta separado del resolver, lÃ³gica HTTP y reglas de negocio deben estarlo, 
;permite reutilizar la LOGICA en diferentes CONTEXTOS (cli, rest, etc)
----------------------------------------------------------------------------------------------
RepoPort->>RepoImpl: Llama implementaciÃ³n JPA
RepoPort
Define Repositorio
;define operaciones de persistencia abstracta ;declara como se acceden a la DB
; ; ; public interface UserRepository {
; ; ;     Optional<User> findById(UserId id);
; ; ;     User save(User user);
; ; ; }
actions ;
-> flujo ;
porque ;desacopla el dominio de la infraestructura. 
;da la posibilidad de cambiar de mysql a mongoDB sin tocar dominio
-------------------------------------------------------------------------------------------
RepoImpl->>DB: SELECT * FROM users...
RepoImpl
Adaptador de repositorio
;implementar persistencia concreta usando JPA en la DB
; ; ; @Repository
; ; ; public class JpaUserRepository implements UserRepository {
    
; ; ;     private final UserJpaRepository jpaRepo;
    
; ; ;     public Optional<User> findById(UserId id) {
; ; ;         return jpaRepo.findById(id.value())
; ; ;             .map(this::toDomain);
; ; ;     }
    
; ; ;     private User toDomain(UserEntity entity) {
; ; ;         return new User(
; ; ;             new UserId(entity.getId()),
; ; ;             entity.getName(),
; ; ;             entity.getEmail()
; ; ;         );
; ; ;     }
; ; ; }
actions ;
-> flujo ;
porque ;Si implementÃ¡ramos JPA directamente en el servicio, estarÃ­as acoplado a Hibernate. 
;Esto permite cambiar tecnologÃ­as fÃ¡cilmente.
--------------------------------------------------------------------------------------------
DB-->>RepoImpl: Datos brutos
DB

-------------------------------------------------------------------------------------------
RepoImpl-->>RepoPort: User entity
-------------------------------------------------------------------------------------------
RepoPort-->>UseCaseImpl: Objeto dominio
-------------------------------------------------------------------------------------------
UseCaseImpl-->>UseCasePort: User validado
-------------------------------------------------------------------------------------------
UseCasePort-->>Resolver: DTO de dominio
-------------------------------------------------------------------------------------------
Resolver-->>Schema: Convierte a GraphQL User
----------------------------------------------------------------------------------
Schema-->>Cliente: { "user": { "name": "Ana", ... } }
---------------------------------------------------------------------

Sin repositorio: La lÃ³gica de negocio se mezcla con SQL/JPQL
Sin servicio: El resolver contendrÃ­a reglas de negocio (imposible reusar)
Sin puertos: Dependencias directas imposibilitan mocks para tests
============================================================================

Beneficios Clave de Esta Estructura
Testabilidad unitaria:
Puedes testear el servicio con un mock del repositorio
Puedes testear el resolver con un mock del servicio

Cambios seguros:
Modificar GraphQL no afecta negocio
Cambiar base de datos no rompe reglas de negocio

Escalabilidad:
Nuevos adaptadores (Ej: aÃ±adir API REST) sin modificar nÃºcleo
FÃ¡cil aÃ±adir cachÃ© (implementando un decorador del repositorio)
===============================================================================

Â¿CuÃ¡ndo es overkill?
Para proyectos:
Muy pequeÃ±os (prototipos, MVPs)
De solo CRUD sin lÃ³gica de negocio compleja
Con requisitos de persistencia fijos y Ãºnicos

En estos casos, podrÃ­as:
Combinar servicio y repositorio
Usar Active Record en lugar de Repository
Eliminar interfaces si solo hay una implementaciÃ³n

La arquitectura hexagonal brilla cuando tienes:
Reglas de negocio complejas
MÃºltiples formas de interacciÃ³n (API, CLI, etc.)
Necesidad de cambiar infraestructura frecuentemente
Sistema de larga vida con evoluciÃ³n constante
======================================================================================

=================================================================================

Flujo de una Query o Mutation GraphQL en Arquitectura de puertos y adaptadores
peticion 
contrato (schema graphql)
conecta (resolvers)
declara (use case)
orquesta (use case service)
abstrae (repository interface)
persiste (repository impl)
actÃºa (DB)


---------------------
recibe 
funcion (valida, transforma, decide)
invoca (envÃ­a)

---------------------------------------------
Principio de Responsabilidad Ãšnica y 
la Regla de Dependencia Inversa (depender de abstracciones, no implementaciones).

Camino de vuelta:
   - Adaptador: Convierte registro â†’ Entidad
   - Servicio: Convierte Entidad â†’ DTO {id, nombre}
   - Resolver: Convierte DTO â†’ {usuario: {id: "X", nombre: "Ana"}}
----------------------------------------------------


graphql 
-input: peticion
process: 
contruye operacion graphql
-output: solicitud 

schema graphql
-imput: solicitud
process: 
valida
-output: argumento graphql

resolver
-input: argumento graphql
process: 
convierte datos a objetos de dominio
maneja errores basicos
-output: consulta de dominio

PORT use case port
-input: consulta de dominio
process:
define contrato abstracto
-output: objeto de dominio validado

ADAPTER "use case service - domain service - use case impl - use case adapter"
-input: objeto de dominio validado
process:
aplica reglas de negocio
toma decisiones
orquesta flujos
-output: instruccion de persistencia

PORT repository port
-input: instruccion de persistencia
process:
define contrato abstracto
-output: entidad de dominio

ADAPTER "repository impl - repository adapter"
-input: entidad de dominio
process:
mapea objetos
convierte a modelo de persitencia
-output: instruccion

DB
-input: instruction
process:
ejecuta instruccion
-output: 
---------------------------------------------------------------------------------------------------
flujo lÃ³gico y arquitectÃ³nico de una operaciÃ³n GraphQL con arquitectura hexagonal


1. GraphQL UI (frontend / comensal)

Input: PeticiÃ³n desde el navegador o frontend

Proceso: Construye y envÃ­a una operaciÃ³n GraphQL (query o mutation)

Output: Solicitud GraphQL enviada al backend

2. schema.graphql (menÃº)

Input: Solicitud GraphQL

Proceso:

Valida el nombre de la operaciÃ³n

Valida los tipos y argumentos

Output: Argumentos correctos para el resolver

3. Resolver (mesero)

Input: Argumentos GraphQL validados

Proceso:

Convierte datos en objetos del dominio

Maneja errores bÃ¡sicos

Llama al caso de uso correspondiente

Output: Consulta o comando del dominio

4. Use Case Port (pedido escrito / contrato del chef)

Input: Consulta o comando del dominio

Proceso:

Define la interfaz (contrato)

Declara quÃ© se necesita del dominio, sin implementar

Output: Objeto del dominio validado

5. Use Case Service (chef)

Input: Objeto del dominio validado

Proceso:

Aplica lÃ³gica de negocio (reglas)

Orquesta llamadas a los repositorios

Output: InstrucciÃ³n de persistencia o resultado

6. Repository Port (pedido a cocina)

Input: InstrucciÃ³n de persistencia

Proceso:

Define el contrato para acceder a los datos

Output: Objeto del dominio listo para persistir

7. Repository Implementation (cocina)

Input: Objeto de dominio

Proceso:

Mapea objeto de dominio a entidad JPA

Usa JPA para acceder a la base de datos

Output: InstrucciÃ³n SQL / resultado persistido

8. Base de Datos (despensa)

Input: InstrucciÃ³n SQL

Proceso:

Ejecuta consulta, inserciÃ³n o actualizaciÃ³n

Output: Datos leÃ­dos o confirmaciÃ³n de guardado

AnalogÃ­a completa con el restaurante (8 elementos)

Comensal (GraphQL UI)

Hace la peticiÃ³n de un plato

MenÃº (schema.graphql)

Muestra quÃ© platos existen y cÃ³mo pedirlos

Mesero (Resolver)

Toma la orden, la valida y la lleva a la cocina

Pedido escrito (Use Case Port)

EspecificaciÃ³n formal de quÃ© se pidiÃ³ y cÃ³mo debe prepararse

Chef (Use Case Service)

Decide cÃ³mo preparar el plato segÃºn reglas del restaurante

Pedido a cocina (Repository Port)

Solicita ingredientes o preparaciÃ³n especÃ­fica a la cocina

Cocina (Repository Impl)

Prepara el plato real con acceso a ingredientes

Despensa (Base de Datos)

Guarda y suministra los ingredientes (datos)



===========================================================================================
GraphQL Input â†’ Comando Dominio â†’ Entidad â†’ Modelo Persistencia â†’ Almacenamiento
=============================================================================================

Validaciones

Logging

CachÃ©

Transformaciones


---------------------------------------------------------

ğŸ§  Resumen del Proyecto: AsistApp
ğŸ¯ Objetivo
Desarrollar una aplicaciÃ³n de gestiÃ³n de asistencias para empleados, usando Quarkus, GraphQL, y arquitectura hexagonal (clean architecture).

ğŸ›ï¸ Arquitectura Hexagonal Aplicada
La app sigue una estructura por capas, separando responsabilidades de forma clara:

java
Copiar cÃ³digo
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ GraphQL UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚         (Frontend - navegador)     â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â–¼
                 schema.graphql (menÃº)
                        â–¼
                 Resolver (mesero)
                        â–¼
            Use Case Port (contrato del chef)
                        â–¼
          Use Case Impl/Service (chef principal)
                        â–¼
           Repository Port (pedido a cocina)
                        â–¼
         Repository Impl (cocina con JPA/SQL)
                        â–¼
             Base de datos PostgreSQL (despensa)
ğŸ“ Estructura de carpetas
plaintext
Copiar cÃ³digo
src/
â””â”€ main/
   â”œâ”€ java/com/joyit/
   â”‚  â”œâ”€ application/usecases/   â† lÃ³gica del negocio
   â”‚  â”œâ”€ domain/model/           â† entidades del dominio
   â”‚  â”œâ”€ domain/ports/in/        â† interfaces de casos de uso
   â”‚  â”œâ”€ domain/ports/out/       â† interfaces de repositorio
   â”‚  â”œâ”€ infrastructure/
   â”‚  â”‚  â”œâ”€ graphql/resolvers/   â† resolvers GraphQL
   â”‚  â”‚  â”œâ”€ persistence/entity/  â† entidades JPA
   â”‚  â”‚  â”œâ”€ persistence/repository/ â† repositorios JPA
   â”‚  â””â”€ AsistApp.java           â† punto de entrada
   â”œâ”€ resources/
   â”‚  â”œâ”€ META-INF/resources/graphql/schema.graphql â† esquema GraphQL
   â”‚  â””â”€ application.properties  â† configuraciÃ³n Quarkus
ğŸ“¦ Dependencias clave (en pom.xml)
quarkus-smallrye-graphql â†’ Para usar GraphQL

quarkus-hibernate-orm-panache â†’ ORM con JPA

quarkus-jdbc-postgresql â†’ Driver PostgreSQL

quarkus-arc â†’ InyecciÃ³n de dependencias

quarkus-rest-jackson, quarkus-rest â†’ (opcional) para REST

quarkus-smallrye-jwt â†’ Seguridad con JWT (si decides usarla)

ğŸ§© Entidades importantes
Attendance.java (Dominio)
id: Int

tipo: String

fecha: String

empleadoId: Int

AttendanceEntity.java (JPA)
Equivalente al modelo Attendance, mapeado con @Entity.

ğŸ”§ Funcionalidad implementada (GraphQL)
âœ… Query
graphql
Copiar cÃ³digo
query {
  listarAsistencias(empleadoId: 1) {
    id
    tipo
    fecha
    empleadoId
  }
}
âœ… Mutation
graphql
Copiar cÃ³digo
mutation {
  registrarAsistencia(
    id: 1,
    tipo: "entrada",
    fecha: "2025-07-29",
    empleadoId: 1
  ) {
    id
    tipo
    fecha
    empleadoId
  }
}
Resolver asociado: AttendanceResolver.java
Llama a los casos de uso

Conecta con GetAttendanceByEmployeeUseCase y RegisterAttendanceUseCase

âœ… Estado actual
ğŸŸ¢ El servidor levanta correctamente en http://localhost:8080/q/graphql-ui

ğŸŸ¢ Se pueden hacer consultas y mutaciones exitosas

ğŸŸ¢ No hay errores en la consola ni conflictos de dependencias

ğŸŸ¢ Diagramas .puml organizados por tipo en uml-diagrams/

ğŸ§ª Se eliminÃ³ el test de ejemplo fallido (GreetingResourceTest)

ğŸ“Œ Se entiende el ciclo de vida completo de una operaciÃ³n GraphQL

---------------------------------------------------------------

ğŸ§  CÃ³mo fluye una peticiÃ³n GraphQL
Frontend (GraphQL Playground o cliente) hace una peticiÃ³n.

schema.graphql valida la estructura de la operaciÃ³n.

Resolver recibe argumentos y llama al caso de uso (interface).

La implementaciÃ³n del caso de uso orquesta la lÃ³gica.

Llama al puerto de repositorio.

La implementaciÃ³n del repositorio convierte a entidad y usa JPA.

La base de datos guarda o devuelve datos.

Todo el camino de vuelta sube hasta el cliente.

--------------------------------------------------------

 Recomendaciones para seguir
âœ… Seguir creando queries y mutations para Employee, UserAccount, etc.

ğŸ¯ Aprender testing con QuarkusTest (cuando estÃ©s listo).

ğŸ“š Estudiar validaciones con Bean Validation (@NotNull, etc.).

ğŸ§© AÃ±adir seguridad (JWT) si se requiere login real.

ğŸ—ƒï¸ Usar mÃ¡s funcionalidades de Panache o repositorios custom.
------------------------------------------------------

Si el backend sÃ­ estÃ¡ corriendo pero el error persiste, necesito los siguientes archivos:
âš ï¸ Puedes enviÃ¡rmelos uno por uno si lo prefieres, o copiar su contenido aquÃ­.

AttendanceResolver.java
(estÃ¡ en infrastructure/graphql/resolvers/)

schema.graphql
(en resources/META-INF/resources/graphql/)

application.properties
(en resources/)

AttendanceEntity.java
(por si hay conflicto con JPA)

GetAttendanceByEmployeeUseCase.java

GetAttendanceByEmployeeService.java

AttendanceRepository.java

AttendanceRepositoryImpl.java


